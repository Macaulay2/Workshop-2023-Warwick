-----------------------------
-- Some tasks for Thursday
--
-- The tasks are not necessarily listed in the order they should be completed
-- Some tasks are completely self-contained


----------
-- TASK --
-- I made a hasty change because I encountered an error with a large example
-- from:
pInclusion := map(tensorRing, pRing, (vars tensorRing)_{numberVariables..numberGenerators-1});
-- to:
pInclusion := map(tensorRing, pRing, (vars tensorRing)_{numberVariables .. (numberVariables + numberGenerators-1)});
-- Does this make sense?


----------
-- TASK --
-- Add to the documentation about the Strategy FourTiTwo
-- (search for DegreeByDegree in the documentation)


----------
-- TASK --
-- Implement hilbertPolynomial of a Subring
-- 0. Make sure you know how the algebra is graded
--    E.g. 
--    > Graded by total degree, 
--    > a grading on the underlying ring,
--    > graded by a special variable (that the user tells you about)
--    Choosing a grading could be an option later. 
--    For now pick one
-- 1. Compute a SAGBI Basis for the subring
--    (make sure it is a full sagbi basis)
-- 2. Compute the NO-body:
-- 2. a) for each sagbi generator f write down the (column) vector v:
--       v_(0,0) = degree of f
--       v_(1,0) .. v_(n,0) = exponent of leadTerm f
--       collect all the column vectors into a matrix M (or better yet, make
--       the matrix in one go using for loops)
matrix for row from 0 to 2 list for col from 0 to 3 list 4*row+col 

--    b) use Polyhedra package function coneFromVData to compute the
--       cone C generated by the matrix M
needsPackage "Polyhedra"
help coneFromVData
help "V- and H-representation"

--    c) construct a polyhedron H, which is the hyperplane of all points
--       x such that x_0 = 1
--    d) use intersection to compute the NO-Body as the intersection of C and H
help (intersection, Polyhedron, Cone)

-- 3. Compute the index of the sub lattice (relative to the linear span of C) 
--    generated by the columns M
--    (not sure how to do this, maybe there's a nice M2 way to do it,
--    otherwise you can write down generators of the ZZ-module generated by
--    the columns of M and then find its determinant)
A = matrix {{2,2,0}, {2,4,6}, {3, 6, 10}}
ZZA = image A
AIndex := det gens ZZA

-- 4. The hilbert polynomial of the algebra is the ehrhart polynomial
--    of the NO-Body, but you need to take care of the index of the lattice
P = convexHull A
1/AIndex * ehrhart P -- Check this is the right way to take care of the index!

-- 5. (optional) store the NO-body and Hilbert polynomial of the subring in
--    its cache table. Use a protected symbol for the key and write some
--    getters and for these objects. If the key doesn't exist in the cache
--    then call the function that constructs it first.

T = new CacheTable from {}
if not T#?"testKey" then (
    -- testKey is not a key of T
    T#"testKey" = 1;
    )
print T#"testKey"
peek T

protect symbol Symb -- somewhere in the package (exports.m2?)
T#Symb = 2
T#Symb





-------------------------------------------------
-- TASK maps between subrings / subring and ring

----------------
-- Discussion --
-- What should a subring be?
-- 1. How should a subring relate to ring?
--    > Which properties of rings would we like subrings to have?
--    > Technical: could these properties be inherited?
-- 2. How should subrings relate to other subrings?
--    > Some kind of rooted tree with the root being a Ring
-- 3. Other properties of subrings that we want
--    > Hilbert functions / polynomials / series
--    > Graded subrings
--    > Substitute for Subrings
--    > LeadTerm for Subrings


---------------
-- TASK
-- Learn more about intersecting subrings 
-- > Can we adapt the current intersection algorithm to intersect multiple
--   (say 3 or more) subrings at once?
-- > find out how we can compute intersections of homogeneous subrings
--   -- what's the algorithm for ideals?
--   -- can we convert it into an algorithm for algebras?
-- > check Algorithm 1 from [Stillman-Tsai 99] which is about
--   intersecting monomial algebras. How does it work?
--   How does it compare with the current algorithm?
-- > How does the method: "intersect" (for ideals) get to take
--   arbitrarily many inputs? (something related to "args")
--   also "intersect" isn't just a MethodFunction, it's a
--   MethodFunctionBinary, what is that? 

---------------
-- TASK
-- Add Beihui's nice subring intersection example as an example
-- If the hilbertPolynomial task is completed then use it as a test for
-- the known Hilbert polynomial 




----------
-- TASK --
-- [Warning: this task isn't fully worked out, ask Ollie]
-- 
-- Update the function internalIsSAGBIProcess
-- If the ambient ring of the supplied SAGBIBasis is a polynomial ring (not a quotient)
-- then use the Strategy FourTiTwo for setting up / updating the compTable.
--
-- Background: isSAGBI is a function that will check to see if a list
-- of polynomials, or the generators of a subring form a SAGBI basis.
-- The function internalIsSAGBIProcess does all the actual checking.
-- The function isSAGBI stores its result using the handy function memoize:
f = n -> n^2  
g = memoize f -- build a function from f that caches the results
g 3
g 4
peek memoizeValues g -- running g again will just look up the answer

-- ... which can be useful, but can also be a pain because we need to completely
-- sanitise and uniformise the user's inputs.
--




------------------------------------------
S = QQ[z_1, z_2, z_3, Degrees => {2,2,2}]
I = ideal(z_1*z_3 - z_2^2)
Q = S/I
peek res I
hilbertSeries I
betti I
------------------------------------------

hilbertPolynomial(Subring) := opts -> S -> (
    -- check the gens are homogenous
    assert(isHomogeneous gens S);
    
    M := leadTerm S;
    exponentMatrix := transpose matrix flatten (first entries M / exponents);
    columnSums := for column from 0 to (numgens source exponentMatrix)-1 list (
        sumValue := (matrix {toList(numgens target exponentMatrix : 1)} * exponentMatrix_{column})_(0,0);
	1/sumValue
	);
    V := exponentMatrix*diagonalMatrix(columnSums);
    basisLattice := (mingens image exponentMatrix);

    -- extend to a basis
    currentIndex := 0;
    while numrows basisLattice > numcols basisLattice do (
	newCol := transpose matrix {for j from 0 to numrows basisLattice -1 list (
		if j == currentIndex then 1 else 0
		)};
	if rank (basisLattice | newCol) == numcols basisLattice + 1 then (
	    basisLattice = basisLattice | newCol;
	    );
	currentIndex = currentIndex + 1;
	);
        
    --print basisLattice;
    assert(det basisLattice == 1);
    
    -- project the vertices down to the lower-dimensional lattice
    NOBodyVertices := transpose compress transpose (basisLattice^(-1)*V);
    NOBody := convexHull(NOBodyVertices);
    --print vertices NOBody;
    ehrhart NOBody    
    )


hilbertPolynomial(Subring, ZZ) := opts -> (S, i) -> (
    M := leadTerm S;
    exponentMatrix := transpose matrix flatten (first entries M / exponents);
    columnSums := for column from 0 to (numgens source exponentMatrix)-1 list 1/exponentMatrix_(i, column);
    V := exponentMatrix*diagonalMatrix(columnSums);
    basisLattice := (mingens image exponentMatrix);
    
    -- extend to a basis
    currentIndex := 0;
    while numrows basisLattice > numcols basisLattice do (
	newCol := transpose matrix {for j from 0 to numrows basisLattice -1 list (
		if j == currentIndex then 1 else 0
		)};
	if rank (basisLattice | newCol) == numcols basisLattice + 1 then (
	    basisLattice = basisLattice | newCol;
	    );
	currentIndex = currentIndex + 1;
	);
        
    --print basisLattice;
    assert(det basisLattice == 1);
    
    -- project the vertices down to the lower-dimensional lattice
    NOBodyVertices := transpose compress transpose (basisLattice^(-1)*V);    
    NOBody := convexHull(NOBodyVertices);
    --print vertices NOBody;
    ehrhart NOBody    
    )
-----------------------
restart
path = prepend("./", path)
needsPackage "SubalgebraBases"
needsPackage "Polyhedra"

-- needsPackage "Polyhedra"
R = QQ[x,y,z]
S = subring matrix {{x^3, y^2, x^5, y^5, z^10, z*y}}
hilbertPolynomial S
vertices NObody S

R = QQ[t, x, y, z]
i = 0
S = subring matrix {{t*x^2, t*x*y, t*z^3, t*x*z}}
hilbertPolynomial(S, 0)
vertices NObody(S, 0)

---------------------
-- See Ollie's github (special weight orders on the Pleucker algebra)
needsPackage "MatchingFields" 
k = 2
n = 5
S = subring diagonalMatchingField(k, n)
transpose gens S --2x2 minors of a 2x5 matrix (as a subring)

R = ambient S
W = {100} | (options R).MonomialOrder#1#1 -- new weight for t
R' = QQ[t, 
    (x := symbol x; x_(1,1) .. x_(k,n)), 
    MonomialOrder => {Weights => W}
    ]
m = map(R', R, (vars R')_{1 .. k*n})

-- t-graded Pleucker Algebra
S' = subring ((R')_0 * (m gens S))
transpose gens S'

hilbertPolynomial(S', 0)

d = k*(n-k) -- dimension = degree of hilbert polynomial
degree Grassmannian(k-1, n-1) / d! -- leading coefficient

vertices NObody(S', 0)
