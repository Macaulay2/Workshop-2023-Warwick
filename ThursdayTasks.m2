-----------------------------
-- Some tasks for Thursday
--
-- The tasks are not necessarily listed in the order they should be completed
-- Some tasks are completely self-contained


----------
-- TASK --
-- I made a hasty change because I encountered an error with a large example
-- from:
pInclusion := map(tensorRing, pRing, (vars tensorRing)_{numberVariables..numberGenerators-1});
-- to:
pInclusion := map(tensorRing, pRing, (vars tensorRing)_{numberVariables .. (numberVariables + numberGenerators-1)});
-- Does this make sense?


----------
-- TASK --
-- Add to the documentation about the Strategy FourTiTwo
-- (search for DegreeByDegree in the documentation)


----------
-- TASK --
-- Implement hilbertPolynomial of a Subring
-- 0. Make sure you know how the algebra is graded
--    E.g. 
--    > Graded by total degree, 
--    > a grading on the underlying ring,
--    > graded by a special variable (that the user tells you about)
--    Choosing a grading could be an option later. 
--    For now pick one
-- 1. Compute a SAGBI Basis for the subring
--    (make sure it is a full sagbi basis)
-- 2. Compute the NO-body:
-- 2. a) for each sagbi generator f write down the (column) vector v:
--       v_(0,0) = degree of f
--       v_(1,0) .. v_(n,0) = exponent of leadTerm f
--       collect all the column vectors into a matrix M (or better yet, make
--       the matrix in one go using for loops)
matrix for row from 0 to 2 list for col from 0 to 3 list 4*row+col 

--    b) use Polyhedra package function coneFromVData to compute the
--       cone C generated by the matrix M
needsPackage "Polyhedra"
help coneFromVData
help "V- and H-representation"

--    c) construct a polyhedron H, which is the hyperplane of all points
--       x such that x_0 = 1
--    d) use intersection to compute the NO-Body as the intersection of C and H
help (intersection, Polyhedron, Cone)

-- 3. Compute the index of the sub lattice (relative to the linear span of C) 
--    generated by the columns M
--    (not sure how to do this, maybe there's a nice M2 way to do it,
--    otherwise you can write down generators of the ZZ-module generated by
--    the columns of M and then find its determinant)
A = matrix {{2,2,0}, {2,4,6}, {3, 6, 10}}
ZZA = image A
AIndex := det gens ZZA

-- 4. The hilbert polynomial of the algebra is the ehrhart polynomial
--    of the NO-Body, but you need to take care of the index of the lattice
P = convexHull A
1/AIndex * ehrhart P -- Check this is the right way to take care of the index!

-- 5. (optional) store the NO-body and Hilbert polynomial of the subring in
--    its cache table. Use a protected symbol for the key and write some
--    getters and for these objects. If the key doesn't exist in the cache
--    then call the function that constructs it first.

T = new CacheTable from {}
if not T#?"testKey" then (
    -- testKey is not a key of T
    T#"testKey" = 1;
    )
print T#"testKey"
peek T

protect symbol Symb -- somewhere in the package (exports.m2?)
T#Symb = 2
T#Symb



----------------
-- Discussion --
-- What should a subring be?
-- 1. How should a subring relate to ring?
--    > Which properties of rings would we like subrings to have?
--    > Technical: could these properties be inherited?
-- 2. How should subrings relate to other subrings?
--    > Some kind of rooted tree with the root being a Ring
-- 3. Other properties of subrings that we want
--    > Hilbert functions / polynomials / series
--    > Graded subrings
--    > Substitute for Subrings
--    > LeadTerm for Subrings


---------------
-- TASK
-- Learn more about intersecting subrings 
-- > Can we adapt the current intersection algorithm to intersect multiple
--   (say 3 or more) subrings at once?
-- > find out how we can compute intersections of homogeneous subrings
--   -- what's the algorithm for ideals?
--   -- can we convert it into an algorithm for algebras?
-- > check Algorithm 1 from [Stillman-Tsai 99] which is about
--   intersecting monomial algebras. How does it work?
--   How does it compare with the current algorithm?
-- > How does the method: "intersect" (for ideals) get to take
--   arbitrarily many inputs? (something related to "args")
--   also "intersect" isn't just a MethodFunction, it's a
--   MethodFunctionBinary, what is that? 

---------------
-- TASK
-- Add Beihui's nice subring intersection example as an example
-- If the hilbertPolynomial task is completed then use it as a test for
-- the known Hilbert polynomial 




----------
-- TASK --
-- [Warning: this task isn't fully worked out, ask Ollie]
-- 
-- Update the function internalIsSAGBIProcess
-- If the ambient ring of the supplied SAGBIBasis is a polynomial ring (not a quotient)
-- then use the Strategy FourTiTwo for setting up / updating the compTable.
--
-- Background: isSAGBI is a function that will check to see if a list
-- of polynomials, or the generators of a subring form a SAGBI basis.
-- The function internalIsSAGBIProcess does all the actual checking.
-- The function isSAGBI stores its result using the handy function memoize:
f = n -> n^2  
g = memoize f -- build a function from f that caches the results
g 3
g 4
peek memoizeValues g -- running g again will just look up the answer

-- ... which can be useful, but can also be a pain because we need to completely
-- sanitise and uniformise the user's inputs.
--

